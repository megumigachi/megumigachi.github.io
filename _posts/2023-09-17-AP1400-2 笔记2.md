---
layout: post
title: "AP1400-2笔记（2）--遇到的问题以及探索和思考"
categories:
  - c++
toc: true
toc_sticky: true
toc_label: 目录
---


## 写在前面

本文记载了完成AP1400-2中遇到的一些问题，由于没有c++基础硬上，可能遇到的问题会太过基础，不过探索总不是坏事，“进一寸有一寸的欢喜”。

## hw6
hw6的q1要实现梯度下降法，给了我相当程度的困扰，主要是测试用例中的调用看起来似乎适配了太多的函数种类，如下：

```c++
//接受lambda函数
    auto min = q1::gradient_descent(0.01, 0.01, [](double a){ return sin(a) + cos(a); });
                                    
//接受一个重载了运算符()的结构体对象
    struct Func
    {
        double operator()(double a) { return cos(a); }
    };
    auto min = q1::gradient_descent(0.01, 0.01, Func{});
    
//接受了一个莫名其妙的模板参数
    struct Func
    {
        double operator()(double a) { return sin(a); }
    };
    auto min = q1::gradient_descent<double, Func>(0.0, 0.01);
```

在查了半天之后，大概确定了一下函数原型

```c++
    // 泛型版本，主要用于第三个测试用例
    template <typename ReturnType = double, typename FuncType>
    ReturnType gradient_descent(ReturnType initial_point, ReturnType learning_rate)
    {      
    };

    // 非泛型版本，用于前两个测试用例
    double gradient_descent(double initial_point, double learning_rate, std::function<double(double)> func)
    {

    };

```

这里的std::function是一个对象包装器，在接受函数和lambda的时候会进行自动包装，如果一个对象实现了重载运算符()也可以被接受，所以前两个用例能适配第二个函数。而第三个用例大概是为了可以适配更多的情况（如不止一个自变量），而引入了一个表示函数本身的模板参数，但感觉就这个例子而言没什么用处，因为如果传入的函数的参数个数都产生了变化，那我觉得大概率要重载，如果没有变化的话，直接把function变成模板变量就可以了。总之，我在实现里还是调用了非泛型版本的函数：

```c++
    template <typename ReturnType = double, typename FuncType>
    ReturnType gradient_descent(ReturnType initial_point, ReturnType learning_rate)
    {
        FuncType func = FuncType();
        // 转换为std::function
        std::function<ReturnType(ReturnType)> stdFunc = func;

        // 委托给非模板版本
        ReturnType result = static_cast<ReturnType>(
            gradient_descent(static_cast<ReturnType>(initial_point), static_cast<ReturnType>(learning_rate), stdFunc));

        return result;
    }
```

这时如果我们传入的FuncType对象和目标函数的参数类型不匹配，static_cast会产生一个转换错误。

令人很惊讶的是，我尝试了一下这段代码，居然也能完成任务：

```c++
    template <typename T, typename F>
    T gradient_descent(T init, T step)
    {
        return gradient_descent(init, step, F());
    }
```

此时如果类型F和目标参数的函数类型不匹配，会产生一个no matching function错误。不得不说c++的语法是不是有点太自由了。